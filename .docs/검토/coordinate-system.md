# 좌표계 및 데이터 융합 상세 설계

## 1. 월드좌표계 정의

### 1.1 좌표계 기준

```
        (0,0)─────────────────────────────────────(1190,0)
          │                                           │
          │                                           │
          │              배터리 표면                   │
          │              (Z = 0 평면)                  │
          │                                           │
          │                                           │
       (0,1960)───────────────────────────────────(1190,1960)
```

| 항목 | 정의 |
|------|------|
| 원점 (0,0,0) | 배터리 표면 왼쪽 위 모서리 |
| X축 | 오른쪽 방향 (+), 범위 0~1190mm |
| Y축 | 아래쪽 방향 (+), 범위 0~1960mm |
| Z축 | 위쪽 방향 (+), 카메라 높이 방향 |
| 단위 | mm (밀리미터) |

### 1.2 카메라 위치

```
       CAM1                                    CAM2
      (0,0,200)                             (1190,0,200)
          ↘                                      ↙
           ╲  45° 틸트                 45° 틸트  ╱
            ╲                                  ╱
             ╲                                ╱
        ┌─────────────────────────────────────────┐
        │                                         │
        │              배터리 표면                 │
        │               (Z=0)                     │
        │                                         │
        └─────────────────────────────────────────┘
             ╱                                ╲
            ╱                                  ╲
           ╱  45° 틸트                 45° 틸트  ╲
          ↗                                      ↖
       CAM3                                    CAM4
     (0,1960,200)                         (1190,1960,200)
```

| 카메라 | 위치 (X, Y, Z) | 틸트 방향 |
|--------|----------------|-----------|
| CAM1 | (0, 0, 200) | 오른쪽+아래 대각선 |
| CAM2 | (1190, 0, 200) | 왼쪽+아래 대각선 |
| CAM3 | (0, 1960, 200) | 오른쪽+위 대각선 |
| CAM4 | (1190, 1960, 200) | 왼쪽+위 대각선 |

---

## 2. 픽셀 → 월드좌표 변환

### 2.1 변환 개요

```
┌─────────────────────────────────────────────────────────────┐
│                     변환 파이프라인                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   픽셀 (px, py)                                             │
│         │                                                   │
│         ▼  [Step 1]                                         │
│   각도 (θh, θv)                                             │
│         │                                                   │
│         ▼  [Step 2]                                         │
│   기본 방향벡터 (dx', dy', dz')                              │
│         │                                                   │
│         ▼  [Step 3]                                         │
│   월드 방향벡터 (dx, dy, dz)                                 │
│         │                                                   │
│         ▼  [Step 4]                                         │
│   교차점 계수 t                                              │
│         │                                                   │
│         ▼  [Step 5]                                         │
│   월드좌표 (Wx, Wy)                                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Step 1: 픽셀 → 각도

```
MLX90640 사양:
├── 해상도: 32 × 24 픽셀
├── FOV: 110° × 75° (수평 × 수직)
└── 중심 픽셀: (15.5, 11.5) - 실수 값

공식:
  θh = (px - 15.5) × (110° / 32)   ← 수평 각도
  θv = (py - 11.5) × (75° / 24)    ← 수직 각도

픽셀당 각도:
  수평: 110° / 32 = 3.44°/pixel
  수직: 75° / 24 = 3.13°/pixel
```

**예시:**
| 픽셀 | 수평 각도 (θh) | 수직 각도 (θv) |
|------|----------------|----------------|
| (0, 0) | -53.3° | -36.0° |
| (16, 12) | +1.7° | +1.6° |
| (31, 23) | +53.3° | +36.0° |

### 2.3 Step 2: 각도 → 기본 방향벡터

```
카메라 로컬 좌표계에서의 방향벡터:

  dx' = tan(θh)
  dy' = tan(θv)
  dz' = 1        ← 카메라가 보는 방향 (정면)

※ 방향벡터란?
   - 각도도 아니고 거리도 아님
   - "어느 방향으로 가는가"를 나타내는 3D 벡터
   - 크기(길이)는 의미 없고 방향만 중요
```

**예시:**
```
θh = 30°, θv = 20° 일 때:
  dx' = tan(30°) = 0.577
  dy' = tan(20°) = 0.364
  dz' = 1

→ 방향벡터 (0.577, 0.364, 1)
→ "오른쪽 0.577, 앞으로 0.364, 정면 1 비율로 이동"
```

### 2.4 Step 3: 틸트 회전 적용

```
카메라가 45° 틸트되어 있으므로 3D 회전행렬 적용:

┌ dx ┐       ┌ dx' ┐
│ dy │ = R × │ dy' │
└ dz ┘       └ dz' ┘

R = 카메라별 3D 회전행렬 (틸트 방향에 따라 다름)
```

**회전행렬 (CAM1 예시 - 45° 대각선 틸트):**
```
     ┌                                        ┐
     │  cos45°   0      sin45°                │
R1 = │  0        cos45° sin45°                │
     │ -sin45°  -sin45° cos45°×cos45°         │
     └                                        ┘

실제 값:
     ┌                    ┐
     │  0.707   0    0.707│
R1 = │  0      0.707 0.707│
     │ -0.707 -0.707 0.5  │
     └                    ┘
```

**각 카메라별 틸트 방향:**
| 카메라 | 틸트 방향 | 회전 |
|--------|-----------|------|
| CAM1 | 오른쪽+아래 | +X, +Y 방향으로 45° |
| CAM2 | 왼쪽+아래 | -X, +Y 방향으로 45° |
| CAM3 | 오른쪽+위 | +X, -Y 방향으로 45° |
| CAM4 | 왼쪽+위 | -X, -Y 방향으로 45° |

### 2.5 Step 4: 광선-평면 교차점 계수

```
광선 공식:
  P(t) = 카메라위치 + t × 방향벡터
  P(t) = (Cx, Cy, Cz) + t × (dx, dy, dz)

배터리 표면 평면:
  Z = 0

교차 조건:
  Cz + t × dz = 0

  ∴ t = -Cz / dz
```

**t의 의미:**
```
t는 "비율" (스칼라 배수)
- 거리도 시간도 아님
- 방향벡터를 몇 배 곱해야 평면에 닿는가

예:
  카메라 높이 Cz = 200mm
  dz = -0.7 (아래 방향)

  t = -200 / (-0.7) = 285.7

  → 방향벡터를 285.7배 하면 배터리 표면 도달
```

### 2.6 Step 5: 월드좌표 계산

```
최종 월드좌표:

  Wx = Cx + t × dx
  Wy = Cy + t × dy
```

**전체 예시 (CAM1, 픽셀 10,5):**
```
입력:
  픽셀: (10, 5)
  카메라 위치: (0, 0, 200)
  틸트: 45° 대각선

Step 1: 픽셀 → 각도
  θh = (10 - 15.5) × 3.44° = -18.9°
  θv = (5 - 11.5) × 3.13° = -20.3°

Step 2: 기본 방향벡터
  dx' = tan(-18.9°) = -0.343
  dy' = tan(-20.3°) = -0.370
  dz' = 1

Step 3: 틸트 적용
  (dx, dy, dz) = R × (dx', dy', dz')
  → (0.465, 0.446, -0.765)  (예시 값)

Step 4: 교차점 계수
  t = -200 / (-0.765) = 261.4

Step 5: 월드좌표
  Wx = 0 + 261.4 × 0.465 = 121.6mm
  Wy = 0 + 261.4 × 0.446 = 116.6mm

결과: 픽셀(10,5) → 월드좌표(121.6, 116.6)mm
```

---

## 3. 룩업테이블 (LUT)

### 3.1 순방향 LUT (픽셀 → 월드좌표)

```
목적: 각 픽셀이 배터리 표면의 어디를 보는가?

구조:
  ForwardLUT[camera_id][px][py] = (Wx, Wy)

예시 (CAM1):
┌──────────┬───────────────────┐
│  픽셀    │   월드좌표 (mm)   │
├──────────┼───────────────────┤
│ (0, 0)   │ (-150.2, -82.5)   │  ← 유효영역 밖
│ (10, 5)  │ (121.6, 116.6)    │
│ (16, 12) │ (595.0, 980.0)    │  ← 배터리 중앙
│ (31, 23) │ (1050.3, 1750.8)  │
└──────────┴───────────────────┘

메모리:
  4카메라 × 32 × 24 × 8바이트(float×2) = 24KB
```

### 3.2 역방향 LUT (격자점 → 픽셀)

```
목적: 배터리 표면의 특정 위치를 어느 픽셀이 보는가?

구조:
  InverseLUT[gx][gy] = {
    cam1_px, cam1_py, cam1_weight,
    cam2_px, cam2_py, cam2_weight,
    cam3_px, cam3_py, cam3_weight,
    cam4_px, cam4_py, cam4_weight
  }

격자 정의 (10mm 간격):
  gx: 0 ~ 118 (1190 / 10 = 119개)
  gy: 0 ~ 195 (1960 / 10 = 196개)

메모리:
  119 × 196 × (4카메라 × 3값 × 4바이트) = 약 1.1MB

※ Flash에 저장, 필요시 부분 로드
```

### 3.3 역방향 LUT 생성 방법

```
for 각 격자점 (gx, gy):
    world_x = gx × 10  // mm
    world_y = gy × 10  // mm

    for 각 카메라 cam:
        // 해당 월드좌표에 가장 가까운 픽셀 찾기
        min_dist = INF
        best_px, best_py = -1, -1

        for px = 0 to 31:
            for py = 0 to 23:
                (wx, wy) = ForwardLUT[cam][px][py]
                dist = sqrt((wx-world_x)² + (wy-world_y)²)

                if dist < min_dist:
                    min_dist = dist
                    best_px = px
                    best_py = py

        // 가중치 계산 (거리 기반)
        weight = 1.0 / (min_dist + 1.0)

        InverseLUT[gx][gy].cam[i] = {best_px, best_py, weight}

    // 가중치 정규화
    total_weight = sum of all weights
    for each cam:
        InverseLUT[gx][gy].cam[i].weight /= total_weight
```

---

## 4. 가중치 융합

### 4.1 가중치 계산 원리

```
기본 원칙: 거리가 가까울수록 신뢰도 높음

격자점 (500, 800)에 대해:
┌────────┬─────────┬──────────────────┬──────────┐
│ 카메라 │ 픽셀    │ LUT 월드좌표     │ 거리     │
├────────┼─────────┼──────────────────┼──────────┤
│ CAM1   │ (18,14) │ (495, 803)       │ 6.4mm    │
│ CAM2   │ (12,15) │ (508, 795)       │ 9.4mm    │
│ CAM3   │ (20,8)  │ (502, 798)       │ 2.8mm    │ ← 가장 가까움
│ CAM4   │ (14,9)  │ (497, 805)       │ 5.8mm    │
└────────┴─────────┴──────────────────┴──────────┘
```

### 4.2 가중치 계산 방법

**방법 1: 역거리 (Inverse Distance)**
```
w = 1 / (거리 + ε)

ε = 1mm (0으로 나누기 방지)
```

**방법 2: 역거리 제곱 (Inverse Distance Squared)**
```
w = 1 / (거리² + ε)

가까운 값을 더 강하게 반영
```

### 4.3 가중치 계산 예시

```
거리: CAM1=6.4, CAM2=9.4, CAM3=2.8, CAM4=5.8 mm

방법 1 (역거리, ε=1):
  w1 = 1/(6.4+1) = 0.135
  w2 = 1/(9.4+1) = 0.096
  w3 = 1/(2.8+1) = 0.263  ← 가장 높음
  w4 = 1/(5.8+1) = 0.147

합계: W = 0.135 + 0.096 + 0.263 + 0.147 = 0.641

정규화:
  w1' = 0.135/0.641 = 0.21 (21%)
  w2' = 0.096/0.641 = 0.15 (15%)
  w3' = 0.263/0.641 = 0.41 (41%)  ← 가장 높음
  w4' = 0.147/0.641 = 0.23 (23%)
```

### 4.4 최종 온도 계산

```
각 카메라 온도:
  T1 = 35.2°C (CAM1)
  T2 = 35.8°C (CAM2)
  T3 = 35.0°C (CAM3)
  T4 = 35.5°C (CAM4)

가중 평균:
  T_final = w1'×T1 + w2'×T2 + w3'×T3 + w4'×T4
          = 0.21×35.2 + 0.15×35.8 + 0.41×35.0 + 0.23×35.5
          = 7.39 + 5.37 + 14.35 + 8.17
          = 35.28°C
```

### 4.5 가중치 시각화

```
격자점 (500, 800)에서의 가중치 분포:

     CAM1 ─────── 21% ───────┐
                              │
     CAM2 ─────── 15% ───────┼──→ 융합 → 35.28°C
                              │
     CAM3 ─────── 41% ───────┤  ← 가장 큰 기여
                              │
     CAM4 ─────── 23% ───────┘
```

---

## 5. 실시간 처리 흐름

### 5.1 전체 흐름

```
┌─────────────────────────────────────────────────────────────┐
│                    매 프레임 (250ms)                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [1] 카메라 데이터 읽기 (~100ms)                            │
│      CAM1[32][24] ← I2C 읽기                               │
│      CAM2[32][24] ← I2C 읽기                               │
│      CAM3[32][24] ← I2C 읽기                               │
│      CAM4[32][24] ← I2C 읽기                               │
│                                                             │
│  [2] 격자점별 융합 (~50ms)                                  │
│      for gx = 0 to 118:                                    │
│        for gy = 0 to 195:                                  │
│          // 역방향 LUT로 픽셀 찾기                          │
│          p1 = InvLUT[gx][gy].cam1 → CAM1[px1][py1]        │
│          p2 = InvLUT[gx][gy].cam2 → CAM2[px2][py2]        │
│          p3 = InvLUT[gx][gy].cam3 → CAM3[px3][py3]        │
│          p4 = InvLUT[gx][gy].cam4 → CAM4[px4][py4]        │
│                                                             │
│          // 가중치 융합 (LUT에 미리 저장된 가중치 사용)       │
│          w1 = InvLUT[gx][gy].cam1.weight                   │
│          w2 = InvLUT[gx][gy].cam2.weight                   │
│          w3 = InvLUT[gx][gy].cam3.weight                   │
│          w4 = InvLUT[gx][gy].cam4.weight                   │
│                                                             │
│          FusedGrid[gx][gy] = w1×p1 + w2×p2 + w3×p3 + w4×p4│
│                                                             │
│  [3] 화재 감지 (~10ms)                                      │
│      - 절대 온도 > 80°C?                                    │
│      - 온도 상승률 > 10°C/min?                              │
│      - 핫스팟 감지?                                         │
│                                                             │
│  [4] 결과 전송 (~50ms)                                      │
│      - Ethernet으로 서버 전송                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 성능 요약

| 단계 | 처리 시간 | 비고 |
|------|----------|------|
| 카메라 읽기 | ~100ms | I2C 4채널 순차 |
| 데이터 융합 | ~50ms | 23,324 격자점 |
| 화재 감지 | ~10ms | 임계값 비교 |
| 네트워크 전송 | ~50ms | UDP 패킷 |
| **총합** | **~210ms** | **4Hz 가능** |

### 5.3 메모리 사용량

| 항목 | 크기 | 저장 위치 |
|------|------|----------|
| 순방향 LUT | 24KB | Flash → RAM |
| 역방향 LUT | 1.1MB | Flash (부분 로드) |
| 카메라 데이터 | 12KB | RAM (4×768×4) |
| 융합 그리드 | 93KB | RAM (119×196×4) |
| **총 RAM** | **~130KB** | **192KB 가용** |

---

## 6. 요약

### 6.1 핵심 개념

```
1. 월드좌표계
   - 배터리 표면 기준 (왼쪽 위 = 원점)
   - 단위: mm

2. 픽셀 → 월드좌표 변환 (5단계)
   픽셀 → 각도 → 방향벡터 → 틸트적용 → 교차점 → 월드좌표

3. 룩업테이블
   - 순방향: 픽셀 → 월드좌표
   - 역방향: 격자점 → 픽셀 + 가중치

4. 가중치 융합
   - 거리 기반 가중치 (가까울수록 높음)
   - 4개 카메라 데이터 가중 평균
```

### 6.2 장점

| 항목 | 효과 |
|------|------|
| LUT 사용 | 실시간 계산 없이 빠른 처리 |
| 가중치 융합 | 노이즈 감소, 정확도 향상 |
| 다중 카메라 | 반사 영향 최소화, 사각지대 제거 |
| 미리 계산 | MCU 부하 최소화 |
